{"ast":null,"code":"import _objectSpread from \"/Users/liuzhao/Documents/Projects/flybird/flybird-web/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _objectWithoutProperties from \"/Users/liuzhao/Documents/Projects/flybird/flybird-web/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nconst _excluded = [\"selected\", \"id\"],\n  _excluded2 = [\"id\", \"selected\", \"children\"],\n  _excluded3 = [\"id\", \"selected\", \"children\"];\nimport \"core-js/modules/esnext.iterator.constructor.js\";\nimport \"core-js/modules/esnext.iterator.every.js\";\nimport \"core-js/modules/esnext.iterator.reduce.js\";\n/* eslint-disable sonarjs/no-identical-functions */\n// Utilities\nimport { toRaw } from 'vue';\nexport const independentSelectStrategy = mandatory => {\n  const strategy = {\n    select: _ref => {\n      let {\n        id,\n        value,\n        selected\n      } = _ref;\n      id = toRaw(id);\n\n      // When mandatory and we're trying to deselect when id\n      // is the only currently selected item then do nothing\n      if (mandatory && !value) {\n        const on = Array.from(selected.entries()).reduce((arr, _ref2) => {\n          let [key, value] = _ref2;\n          if (value === 'on') arr.push(key);\n          return arr;\n        }, []);\n        if (on.length === 1 && on[0] === id) return selected;\n      }\n      selected.set(id, value ? 'on' : 'off');\n      return selected;\n    },\n    in: (v, children, parents) => {\n      let map = new Map();\n      for (const id of v || []) {\n        map = strategy.select({\n          id,\n          value: true,\n          selected: new Map(map),\n          children,\n          parents\n        });\n      }\n      return map;\n    },\n    out: v => {\n      const arr = [];\n      for (const [key, value] of v.entries()) {\n        if (value === 'on') arr.push(key);\n      }\n      return arr;\n    }\n  };\n  return strategy;\n};\nexport const independentSingleSelectStrategy = mandatory => {\n  const parentStrategy = independentSelectStrategy(mandatory);\n  const strategy = {\n    select: _ref3 => {\n      let {\n          selected,\n          id\n        } = _ref3,\n        rest = _objectWithoutProperties(_ref3, _excluded);\n      id = toRaw(id);\n      const singleSelected = selected.has(id) ? new Map([[id, selected.get(id)]]) : new Map();\n      return parentStrategy.select(_objectSpread(_objectSpread({}, rest), {}, {\n        id,\n        selected: singleSelected\n      }));\n    },\n    in: (v, children, parents) => {\n      let map = new Map();\n      if (v?.length) {\n        map = parentStrategy.in(v.slice(0, 1), children, parents);\n      }\n      return map;\n    },\n    out: (v, children, parents) => {\n      return parentStrategy.out(v, children, parents);\n    }\n  };\n  return strategy;\n};\nexport const leafSelectStrategy = mandatory => {\n  const parentStrategy = independentSelectStrategy(mandatory);\n  const strategy = {\n    select: _ref4 => {\n      let {\n          id,\n          selected,\n          children\n        } = _ref4,\n        rest = _objectWithoutProperties(_ref4, _excluded2);\n      id = toRaw(id);\n      if (children.has(id)) return selected;\n      return parentStrategy.select(_objectSpread({\n        id,\n        selected,\n        children\n      }, rest));\n    },\n    in: parentStrategy.in,\n    out: parentStrategy.out\n  };\n  return strategy;\n};\nexport const leafSingleSelectStrategy = mandatory => {\n  const parentStrategy = independentSingleSelectStrategy(mandatory);\n  const strategy = {\n    select: _ref5 => {\n      let {\n          id,\n          selected,\n          children\n        } = _ref5,\n        rest = _objectWithoutProperties(_ref5, _excluded3);\n      id = toRaw(id);\n      if (children.has(id)) return selected;\n      return parentStrategy.select(_objectSpread({\n        id,\n        selected,\n        children\n      }, rest));\n    },\n    in: parentStrategy.in,\n    out: parentStrategy.out\n  };\n  return strategy;\n};\nexport const classicSelectStrategy = mandatory => {\n  const strategy = {\n    select: _ref6 => {\n      let {\n        id,\n        value,\n        selected,\n        children,\n        parents\n      } = _ref6;\n      id = toRaw(id);\n      const original = new Map(selected);\n      const items = [id];\n      while (items.length) {\n        const item = items.shift();\n        selected.set(toRaw(item), value ? 'on' : 'off');\n        if (children.has(item)) {\n          items.push(...children.get(item));\n        }\n      }\n      let parent = toRaw(parents.get(id));\n      while (parent) {\n        const childrenIds = children.get(parent);\n        const everySelected = childrenIds.every(cid => selected.get(toRaw(cid)) === 'on');\n        const noneSelected = childrenIds.every(cid => !selected.has(toRaw(cid)) || selected.get(toRaw(cid)) === 'off');\n        selected.set(parent, everySelected ? 'on' : noneSelected ? 'off' : 'indeterminate');\n        parent = toRaw(parents.get(parent));\n      }\n\n      // If mandatory and planned deselect results in no selected\n      // items then we can't do it, so return original state\n      if (mandatory && !value) {\n        const on = Array.from(selected.entries()).reduce((arr, _ref7) => {\n          let [key, value] = _ref7;\n          if (value === 'on') arr.push(key);\n          return arr;\n        }, []);\n        if (on.length === 0) return original;\n      }\n      return selected;\n    },\n    in: (v, children, parents) => {\n      let map = new Map();\n      for (const id of v || []) {\n        map = strategy.select({\n          id,\n          value: true,\n          selected: new Map(map),\n          children,\n          parents\n        });\n      }\n      return map;\n    },\n    out: (v, children) => {\n      const arr = [];\n      for (const [key, value] of v.entries()) {\n        if (value === 'on' && !children.has(key)) arr.push(key);\n      }\n      return arr;\n    }\n  };\n  return strategy;\n};","map":{"version":3,"names":["toRaw","independentSelectStrategy","mandatory","strategy","select","_ref","id","value","selected","on","Array","from","entries","reduce","arr","_ref2","key","push","length","set","in","v","children","parents","map","Map","out","independentSingleSelectStrategy","parentStrategy","_ref3","rest","_objectWithoutProperties","_excluded","singleSelected","has","get","_objectSpread","slice","leafSelectStrategy","_ref4","_excluded2","leafSingleSelectStrategy","_ref5","_excluded3","classicSelectStrategy","_ref6","original","items","item","shift","parent","childrenIds","everySelected","every","cid","noneSelected","_ref7"],"sources":["../../../src/composables/nested/selectStrategies.ts"],"sourcesContent":["/* eslint-disable sonarjs/no-identical-functions */\n// Utilities\nimport { toRaw } from 'vue'\n\nexport type SelectStrategyFn = (data: {\n  id: unknown\n  value: boolean\n  selected: Map<unknown, 'on' | 'off' | 'indeterminate'>\n  children: Map<unknown, unknown[]>\n  parents: Map<unknown, unknown>\n  event?: Event\n}) => Map<unknown, 'on' | 'off' | 'indeterminate'>\n\nexport type SelectStrategyTransformInFn = (\n  v: readonly unknown[] | undefined,\n  children: Map<unknown, unknown[]>,\n  parents: Map<unknown, unknown>,\n) => Map<unknown, 'on' | 'off' | 'indeterminate'>\n\nexport type SelectStrategyTransformOutFn = (\n  v: Map<unknown, 'on' | 'off' | 'indeterminate'>,\n  children: Map<unknown, unknown[]>,\n  parents: Map<unknown, unknown>,\n) => unknown[]\n\nexport type SelectStrategy = {\n  select: SelectStrategyFn\n  in: SelectStrategyTransformInFn\n  out: SelectStrategyTransformOutFn\n}\n\nexport const independentSelectStrategy = (mandatory?: boolean): SelectStrategy => {\n  const strategy: SelectStrategy = {\n    select: ({ id, value, selected }) => {\n      id = toRaw(id)\n\n      // When mandatory and we're trying to deselect when id\n      // is the only currently selected item then do nothing\n      if (mandatory && !value) {\n        const on = Array.from(selected.entries())\n          .reduce((arr, [key, value]) => {\n            if (value === 'on') arr.push(key)\n            return arr\n          }, [] as unknown[])\n        if (on.length === 1 && on[0] === id) return selected\n      }\n\n      selected.set(id, value ? 'on' : 'off')\n\n      return selected\n    },\n    in: (v, children, parents) => {\n      let map = new Map()\n\n      for (const id of (v || [])) {\n        map = strategy.select({\n          id,\n          value: true,\n          selected: new Map(map),\n          children,\n          parents,\n        })\n      }\n\n      return map\n    },\n    out: v => {\n      const arr = []\n\n      for (const [key, value] of v.entries()) {\n        if (value === 'on') arr.push(key)\n      }\n\n      return arr\n    },\n  }\n\n  return strategy\n}\n\nexport const independentSingleSelectStrategy = (mandatory?: boolean): SelectStrategy => {\n  const parentStrategy = independentSelectStrategy(mandatory)\n\n  const strategy: SelectStrategy = {\n    select: ({ selected, id, ...rest }) => {\n      id = toRaw(id)\n      const singleSelected = selected.has(id) ? new Map([[id, selected.get(id)!]]) : new Map()\n      return parentStrategy.select({ ...rest, id, selected: singleSelected })\n    },\n    in: (v, children, parents) => {\n      let map = new Map()\n\n      if (v?.length) {\n        map = parentStrategy.in(v.slice(0, 1), children, parents)\n      }\n\n      return map\n    },\n    out: (v, children, parents) => {\n      return parentStrategy.out(v, children, parents)\n    },\n  }\n\n  return strategy\n}\n\nexport const leafSelectStrategy = (mandatory?: boolean): SelectStrategy => {\n  const parentStrategy = independentSelectStrategy(mandatory)\n\n  const strategy: SelectStrategy = {\n    select: ({ id, selected, children, ...rest }) => {\n      id = toRaw(id)\n      if (children.has(id)) return selected\n\n      return parentStrategy.select({ id, selected, children, ...rest })\n    },\n    in: parentStrategy.in,\n    out: parentStrategy.out,\n  }\n\n  return strategy\n}\n\nexport const leafSingleSelectStrategy = (mandatory?: boolean): SelectStrategy => {\n  const parentStrategy = independentSingleSelectStrategy(mandatory)\n\n  const strategy: SelectStrategy = {\n    select: ({ id, selected, children, ...rest }) => {\n      id = toRaw(id)\n      if (children.has(id)) return selected\n\n      return parentStrategy.select({ id, selected, children, ...rest })\n    },\n    in: parentStrategy.in,\n    out: parentStrategy.out,\n  }\n\n  return strategy\n}\n\nexport const classicSelectStrategy = (mandatory?: boolean): SelectStrategy => {\n  const strategy: SelectStrategy = {\n    select: ({ id, value, selected, children, parents }) => {\n      id = toRaw(id)\n      const original = new Map(selected)\n\n      const items = [id]\n\n      while (items.length) {\n        const item = items.shift()!\n\n        selected.set(toRaw(item), value ? 'on' : 'off')\n\n        if (children.has(item)) {\n          items.push(...children.get(item)!)\n        }\n      }\n\n      let parent = toRaw(parents.get(id))\n\n      while (parent) {\n        const childrenIds = children.get(parent)!\n        const everySelected = childrenIds.every(cid => selected.get(toRaw(cid)) === 'on')\n        const noneSelected = childrenIds.every(cid => !selected.has(toRaw(cid)) || selected.get(toRaw(cid)) === 'off')\n\n        selected.set(parent, everySelected ? 'on' : noneSelected ? 'off' : 'indeterminate')\n\n        parent = toRaw(parents.get(parent))\n      }\n\n      // If mandatory and planned deselect results in no selected\n      // items then we can't do it, so return original state\n      if (mandatory && !value) {\n        const on = Array.from(selected.entries())\n          .reduce((arr, [key, value]) => {\n            if (value === 'on') arr.push(key)\n            return arr\n          }, [] as unknown[])\n        if (on.length === 0) return original\n      }\n\n      return selected\n    },\n    in: (v, children, parents) => {\n      let map = new Map()\n\n      for (const id of (v || [])) {\n        map = strategy.select({\n          id,\n          value: true,\n          selected: new Map(map),\n          children,\n          parents,\n        })\n      }\n\n      return map\n    },\n    out: (v, children) => {\n      const arr = []\n\n      for (const [key, value] of v.entries()) {\n        if (value === 'on' && !children.has(key)) arr.push(key)\n      }\n\n      return arr\n    },\n  }\n\n  return strategy\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}