{"ast":null,"code":"import _objectSpread from \"/Users/liuzhao/Documents/Projects/flybird/flybird-web/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _objectWithoutProperties from \"/Users/liuzhao/Documents/Projects/flybird/flybird-web/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nconst _excluded = [\"activated\", \"id\"],\n  _excluded2 = [\"id\", \"activated\", \"children\"],\n  _excluded3 = [\"id\", \"activated\", \"children\"];\n/* eslint-disable sonarjs/no-identical-functions */\n// Utilities\nimport { toRaw } from 'vue';\nimport { wrapInArray } from \"../../util/index.mjs\";\nexport const independentActiveStrategy = mandatory => {\n  const strategy = {\n    activate: _ref => {\n      let {\n        id,\n        value,\n        activated\n      } = _ref;\n      id = toRaw(id);\n\n      // When mandatory and we're trying to deselect when id\n      // is the only currently selected item then do nothing\n      if (mandatory && !value && activated.size === 1 && activated.has(id)) return activated;\n      if (value) {\n        activated.add(id);\n      } else {\n        activated.delete(id);\n      }\n      return activated;\n    },\n    in: (v, children, parents) => {\n      let set = new Set();\n      if (v != null) {\n        for (const id of wrapInArray(v)) {\n          set = strategy.activate({\n            id,\n            value: true,\n            activated: new Set(set),\n            children,\n            parents\n          });\n        }\n      }\n      return set;\n    },\n    out: v => {\n      return Array.from(v);\n    }\n  };\n  return strategy;\n};\nexport const independentSingleActiveStrategy = mandatory => {\n  const parentStrategy = independentActiveStrategy(mandatory);\n  const strategy = {\n    activate: _ref2 => {\n      let {\n          activated,\n          id\n        } = _ref2,\n        rest = _objectWithoutProperties(_ref2, _excluded);\n      id = toRaw(id);\n      const singleSelected = activated.has(id) ? new Set([id]) : new Set();\n      return parentStrategy.activate(_objectSpread(_objectSpread({}, rest), {}, {\n        id,\n        activated: singleSelected\n      }));\n    },\n    in: (v, children, parents) => {\n      let set = new Set();\n      if (v != null) {\n        const arr = wrapInArray(v);\n        if (arr.length) {\n          set = parentStrategy.in(arr.slice(0, 1), children, parents);\n        }\n      }\n      return set;\n    },\n    out: (v, children, parents) => {\n      return parentStrategy.out(v, children, parents);\n    }\n  };\n  return strategy;\n};\nexport const leafActiveStrategy = mandatory => {\n  const parentStrategy = independentActiveStrategy(mandatory);\n  const strategy = {\n    activate: _ref3 => {\n      let {\n          id,\n          activated,\n          children\n        } = _ref3,\n        rest = _objectWithoutProperties(_ref3, _excluded2);\n      id = toRaw(id);\n      if (children.has(id)) return activated;\n      return parentStrategy.activate(_objectSpread({\n        id,\n        activated,\n        children\n      }, rest));\n    },\n    in: parentStrategy.in,\n    out: parentStrategy.out\n  };\n  return strategy;\n};\nexport const leafSingleActiveStrategy = mandatory => {\n  const parentStrategy = independentSingleActiveStrategy(mandatory);\n  const strategy = {\n    activate: _ref4 => {\n      let {\n          id,\n          activated,\n          children\n        } = _ref4,\n        rest = _objectWithoutProperties(_ref4, _excluded3);\n      id = toRaw(id);\n      if (children.has(id)) return activated;\n      return parentStrategy.activate(_objectSpread({\n        id,\n        activated,\n        children\n      }, rest));\n    },\n    in: parentStrategy.in,\n    out: parentStrategy.out\n  };\n  return strategy;\n};","map":{"version":3,"names":["toRaw","wrapInArray","independentActiveStrategy","mandatory","strategy","activate","_ref","id","value","activated","size","has","add","delete","in","v","children","parents","set","Set","out","Array","from","independentSingleActiveStrategy","parentStrategy","_ref2","rest","_objectWithoutProperties","_excluded","singleSelected","_objectSpread","arr","length","slice","leafActiveStrategy","_ref3","_excluded2","leafSingleActiveStrategy","_ref4","_excluded3"],"sources":["../../../src/composables/nested/activeStrategies.ts"],"sourcesContent":["/* eslint-disable sonarjs/no-identical-functions */\n// Utilities\nimport { toRaw } from 'vue'\nimport { wrapInArray } from '@/util'\n\nexport type ActiveStrategyFn = (data: {\n  id: unknown\n  value: boolean\n  activated: Set<unknown>\n  children: Map<unknown, unknown[]>\n  parents: Map<unknown, unknown>\n  event?: Event\n}) => Set<unknown>\n\nexport type ActiveStrategyTransformInFn = (\n  v: unknown | undefined,\n  children: Map<unknown, unknown[]>,\n  parents: Map<unknown, unknown>,\n) => Set<unknown>\n\nexport type ActiveStrategyTransformOutFn = (\n  v: Set<unknown>,\n  children: Map<unknown, unknown[]>,\n  parents: Map<unknown, unknown>,\n) => unknown\n\nexport type ActiveStrategy = {\n  activate: ActiveStrategyFn\n  in: ActiveStrategyTransformInFn\n  out: ActiveStrategyTransformOutFn\n}\n\nexport const independentActiveStrategy = (mandatory?: boolean): ActiveStrategy => {\n  const strategy: ActiveStrategy = {\n    activate: ({ id, value, activated }) => {\n      id = toRaw(id)\n\n      // When mandatory and we're trying to deselect when id\n      // is the only currently selected item then do nothing\n      if (mandatory && !value && activated.size === 1 && activated.has(id)) return activated\n\n      if (value) {\n        activated.add(id)\n      } else {\n        activated.delete(id)\n      }\n\n      return activated\n    },\n    in: (v, children, parents) => {\n      let set = new Set()\n\n      if (v != null) {\n        for (const id of wrapInArray(v)) {\n          set = strategy.activate({\n            id,\n            value: true,\n            activated: new Set(set),\n            children,\n            parents,\n          })\n        }\n      }\n\n      return set\n    },\n    out: v => {\n      return Array.from(v)\n    },\n  }\n\n  return strategy\n}\n\nexport const independentSingleActiveStrategy = (mandatory?: boolean): ActiveStrategy => {\n  const parentStrategy = independentActiveStrategy(mandatory)\n\n  const strategy: ActiveStrategy = {\n    activate: ({ activated, id, ...rest }) => {\n      id = toRaw(id)\n      const singleSelected = activated.has(id) ? new Set([id]) : new Set()\n      return parentStrategy.activate({ ...rest, id, activated: singleSelected })\n    },\n    in: (v, children, parents) => {\n      let set = new Set()\n\n      if (v != null) {\n        const arr = wrapInArray(v)\n        if (arr.length) {\n          set = parentStrategy.in(arr.slice(0, 1), children, parents)\n        }\n      }\n\n      return set\n    },\n    out: (v, children, parents) => {\n      return parentStrategy.out(v, children, parents)\n    },\n  }\n\n  return strategy\n}\n\nexport const leafActiveStrategy = (mandatory?: boolean): ActiveStrategy => {\n  const parentStrategy = independentActiveStrategy(mandatory)\n\n  const strategy: ActiveStrategy = {\n    activate: ({ id, activated, children, ...rest }) => {\n      id = toRaw(id)\n      if (children.has(id)) return activated\n\n      return parentStrategy.activate({ id, activated, children, ...rest })\n    },\n    in: parentStrategy.in,\n    out: parentStrategy.out,\n  }\n\n  return strategy\n}\n\nexport const leafSingleActiveStrategy = (mandatory?: boolean): ActiveStrategy => {\n  const parentStrategy = independentSingleActiveStrategy(mandatory)\n\n  const strategy: ActiveStrategy = {\n    activate: ({ id, activated, children, ...rest }) => {\n      id = toRaw(id)\n      if (children.has(id)) return activated\n\n      return parentStrategy.activate({ id, activated, children, ...rest })\n    },\n    in: parentStrategy.in,\n    out: parentStrategy.out,\n  }\n\n  return strategy\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}